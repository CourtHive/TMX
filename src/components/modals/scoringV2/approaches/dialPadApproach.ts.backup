/**
 * Dial Pad score entry approach
 * Builds score string incrementally using matchUpFormat rules
 */
import { renderMatchUp } from 'courthive-components';
import { tournamentEngine, matchUpFormatCode } from 'tods-competition-factory';
import { tidyScore } from '../utils/scoreValidator';
import type { RenderScoreEntryParams, ScoreOutcome } from '../types';

type EntryState = {
  digits: string; // Raw digits: "36366" becomes "3-6 3-6 6"
  setTo: number;
  tiebreakAt: number;
};

export function renderDialPadScoreEntry(params: RenderScoreEntryParams): void {
  const { matchUp, container, onScoreChange } = params;

  try {
    container.innerHTML = '';
    container.style.display = 'flex';
    container.style.flexDirection = 'column';
    container.style.gap = '1em';

    // Parse match format
    const parsedFormat = matchUpFormatCode.parse(matchUp.matchUpFormat || 'SET3-S:6/TB7');
    const setTo = parsedFormat?.setFormat?.setTo || 6;
    const tiebreakAt = parsedFormat?.setFormat?.tiebreakAt || setTo;

    // State: just raw digits
    const state: EntryState = {
      digits: '',
      setTo,
      tiebreakAt,
    };

    // MatchUp display container
    const matchUpContainer = document.createElement('div');
    matchUpContainer.style.marginBottom = '0.5em';
    container.appendChild(matchUpContainer);

    // Match format selector
    if (matchUp.matchUpFormat) {
      const formatDisplay = document.createElement('div');
      formatDisplay.style.fontSize = '0.9em';
      formatDisplay.style.marginBottom = '0.5em';
      formatDisplay.style.display = 'flex';
      formatDisplay.style.alignItems = 'center';
      formatDisplay.style.gap = '0.5em';
      
      const formatLabel = document.createElement('span');
      formatLabel.textContent = 'Format:';
      formatLabel.style.color = '#666';
      formatDisplay.appendChild(formatLabel);
      
      const formatButton = document.createElement('button');
      formatButton.textContent = matchUp.matchUpFormat;
      formatButton.className = 'button';
      formatButton.style.fontSize = '0.9em';
      formatButton.style.padding = '0.2em 0.5em';
      formatButton.style.cursor = 'pointer';
      formatButton.title = 'Click to edit format';
      formatButton.addEventListener('click', async () => {
        const { getMatchUpFormat } = await import('components/modals/matchUpFormat/matchUpFormat');
        getMatchUpFormat({
          existingMatchUpFormat: matchUp.matchUpFormat,
          callback: (newFormat: string) => {
            if (newFormat && newFormat !== matchUp.matchUpFormat) {
              matchUp.matchUpFormat = newFormat;
              formatButton.textContent = newFormat;
              container.innerHTML = '';
              renderDialPadScoreEntry({ matchUp, container, onScoreChange });
            }
          }
        } as any);
      });
      formatDisplay.appendChild(formatButton);
      container.appendChild(formatDisplay);
    }

    // Score display (light blue)
    const scoreDisplay = document.createElement('div');
    scoreDisplay.style.fontSize = '2em';
    scoreDisplay.style.color = '#64B5F6';
    scoreDisplay.style.textAlign = 'center';
    scoreDisplay.style.padding = '0.5em';
    scoreDisplay.style.fontWeight = 'bold';
    scoreDisplay.style.minHeight = '1.5em';
    scoreDisplay.style.maxWidth = '300px';
    scoreDisplay.style.margin = '0 auto';
    scoreDisplay.textContent = '-';
    container.appendChild(scoreDisplay);

    // Dial pad
    const dialPadContainer = document.createElement('div');
    dialPadContainer.style.display = 'grid';
    dialPadContainer.style.gridTemplateColumns = 'repeat(3, 1fr)';
    dialPadContainer.style.gap = '0.5em';
    dialPadContainer.style.maxWidth = '300px';
    dialPadContainer.style.margin = '0 auto';
    container.appendChild(dialPadContainer);

    // Convert raw digits to formatted score string
    const formatScoreString = (digits: string): string => {
      if (!digits) return '';
      
      let result = '';
      let i = 0;
      
      while (i < digits.length) {
        let side1 = '';
        let side2 = '';
        let tb1 = '';
        let tb2 = '';
        
        // Parse side1
        while (i < digits.length) {
          side1 += digits[i];
          i++;
          const val = parseInt(side1);
          if (side1.length >= 2 || (side1.length === 1 && val > setTo)) break;
        }
        
        // Parse side2
        while (i < digits.length) {
          side2 += digits[i];
          i++;
          const val = parseInt(side2);
          if (side2.length >= 2 || (side2.length === 1 && val > setTo)) break;
        }
        
        if (!side2) {
          // Incomplete set
          if (result) result += ' ';
          result += side1;
          break;
        }
        
        const s1 = parseInt(side1);
        const s2 = parseInt(side2);
        
        // Check for tiebreak
        const needsTiebreak = (s1 === tiebreakAt && s2 === tiebreakAt) ||
                             (s1 === tiebreakAt + 1 && s2 === tiebreakAt) ||
                             (s2 === tiebreakAt + 1 && s1 === tiebreakAt);
        
        if (needsTiebreak) {
          // Parse tiebreak scores
          while (i < digits.length && tb1.length < 2) {
            tb1 += digits[i];
            i++;
          }
          while (i < digits.length && tb2.length < 2) {
            tb2 += digits[i];
            i++;
          }
          
          if (result) result += ' ';
          if (tb2) {
            result += `${side1}-${side2}(${tb1}-${tb2})`;
          } else if (tb1) {
            result += `${side1}-${side2}(${tb1}`;
          } else {
            result += `${side1}-${side2}(`;
          }
        } else {
          // Regular set
          if (result) result += ' ';
          result += `${side1}-${side2}`;
        }
      }
      
      return result;
    };

    // Update matchUp display using factory
    const updateMatchUpDisplay = (scoreString: string) => {
      if (!scoreString) {
        matchUpContainer.innerHTML = '';
        const matchUpElement = renderMatchUp({
          matchUp,
          isLucky: true,
          composition: { configuration: { participantDetail: 'TEAM' } },
        });
        if (matchUpElement) matchUpContainer.appendChild(matchUpElement);
        return;
      }
      
      try {
        const outcome = tournamentEngine.generateMatchUpOutcomeFromString({
          matchUpFormat: matchUp.matchUpFormat,
          scoreString,
        });
        
        const displayMatchUp = {
          ...matchUp,
          score: outcome?.score,
          winningSide: outcome?.winningSide,
          matchUpStatus: outcome?.matchUpStatus || matchUp.matchUpStatus,
        };

        matchUpContainer.innerHTML = '';
        const matchUpElement = renderMatchUp({
          matchUp: displayMatchUp,
          isLucky: true,
          composition: { configuration: { participantDetail: 'TEAM' } },
        });
        
        if (matchUpElement) matchUpContainer.appendChild(matchUpElement);
      } catch (error) {
        console.error('Error parsing score:', error);
      }
    };

    // Update display
    const updateDisplay = () => {
      const scoreString = formatScore(state.digits);
      scoreDisplay.textContent = scoreString || '-';
      updateMatchUpDisplay(scoreString);
      
      const tidyResult = tidyScore(scoreString);
      const outcome: ScoreOutcome = {
        isValid: !tidyResult.error && scoreString.length > 0,
        sets: [],
        score: tidyResult.tidyScore,
        matchUpStatus: tidyResult.matchUpStatus,
        error: tidyResult.error,
        matchUpFormat: matchUp.matchUpFormat,
      };
      
      onScoreChange(outcome);
      
      const clearBtn = document.getElementById('clearScoreV2') as HTMLButtonElement;
      if (clearBtn) clearBtn.disabled = state.digits.length === 0;
    };

    // Handle digit press
    const handleDigitPress = (digit: number) => {
      state.digits += digit.toString();
      updateDisplay();
    };

    // Handle delete
    const handleDelete = () => {
      if (state.digits.length > 0) {
        state.digits = state.digits.slice(0, -1);
        updateDisplay();
      }
    };

    // Create dial pad buttons
    const buttons = [
      { label: '1', value: 1 },
      { label: '2', value: 2 },
      { label: '3', value: 3 },
      { label: '4', value: 4 },
      { label: '5', value: 5 },
      { label: '6', value: 6 },
      { label: '7', value: 7 },
      { label: '8', value: 8 },
      { label: '9', value: 9 },
      { label: 'âŒ«', value: 'delete', isSpecial: true },
      { label: '0', value: 0 },
      { label: '-', value: 'minus', isSpecial: true },
    ];

    buttons.forEach(btn => {
      const button = document.createElement('button');
      button.className = 'button is-large';
      button.textContent = btn.label;
      button.style.fontSize = '1.5em';
      button.style.height = '60px';
      
      if (btn.isSpecial) {
        button.style.backgroundColor = '#f0f0f0';
      }
      
      button.onclick = () => {
        if (btn.value === 'delete') {
          handleDelete();
        } else if (btn.value === 'minus') {
          // Minus doesn't do anything in this approach
        } else {
          handleDigitPress(btn.value as number);
        }
      };
      
      dialPadContainer.appendChild(button);
    });

    // Keyboard support
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key >= '0' && e.key <= '9') {
        e.preventDefault();
        handleDigitPress(parseInt(e.key));
      } else if (e.key === 'Backspace' || e.key === 'Delete') {
        e.preventDefault();
        handleDelete();
      }
    };

    document.addEventListener('keydown', handleKeyDown);
    
    // Cleanup
    const cleanup = () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
    
    (window as any).cleanupDialPad = cleanup;

    // Initial display
    updateMatchUpDisplay('');
    updateDisplay();
  } catch (error) {
    console.error('Error rendering dial pad:', error);
    container.innerHTML = `<p style="color: red;">Error: ${error instanceof Error ? error.message : 'Unknown error'}</p>`;
  }
}
